#!/bin/php
<?php

# Detect and block suspicious activity.
#
# {{ ansible_managed }}

$short_options = "vq";
$long_options = [
  "limit:",
];

// Use getopt() to parse both short and long options
// The third parameter is used to store the index where argument parsing stops
$options = getopt($short_options, $long_options, $rest_index);

// Get the non-flagged arguments using the index from getopt()
$positional_args = array_slice($argv, $rest_index);

// The first positional argument is our mandatory filename
$logFile = $positional_args[0] ?? '/var/log/nginx/access.log';

if ($logFile == '-') {
  $logFile = 'php://stdin';
}
else {
  if (!file_exists($logFile)) {
    die("Log file does not exist.");
  }
}

// Note that for toggles, they are a key in the array and their value is FALSE
// Ex: quiet=>FALSE means that the user typed "--quiet"
$limit = $options['limit'] ?? $options['l'] ?? 600;
$verbose = isset($options['v']) || isset($options['verbose']);
$quiet = isset($options['q']) || isset($options['quiet']);

// Read all lines from the log file
$lines = file($logFile, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

// Array to store IP address counts
$ipCounts = [];

// Process each line
foreach ($lines as $line) {
  // Extract the IP address (first field in the log line)
  preg_match('/^(\S+)/', $line, $matches);

  if (isset($matches[1])) {
    $ip = $matches[1];

    // Remove quotes
    $ip = str_replace('"', '', $ip);

    // If IPv4, remove the last part of the IP
    $parts = explode('.', $ip);
    if (count($parts) == 4) {
      $parts[3] = '0';
      $ip = implode('.', $parts);
    }

    // Increment the count for the IP address
    if (isset($ipCounts[$ip])) {
      $ipCounts[$ip]++;
    } else {
      $ipCounts[$ip] = 1;
    }
  }
}

if ($verbose) {
  echo "Processed " . count($lines) . " log lines\n";
  echo "Found " . count($ipCounts) . " IP blocks\n";
}

// Sort IP addresses by count in descending order
arsort($ipCounts);

// Output the top IP addresses
$stop = 50;

foreach ($ipCounts as $ip => $count) {
  // Lookup country/org information
  $apiUrl = "http://ipinfo.io/{$ip}/json";
  $response = file_get_contents($apiUrl);
  $info = json_decode($response, true);

  // Lookup the reverse DNS
  $reverse_dns = `host $ip | awk '{ print $5 }'`;
  $reverse_dns = str_replace(["\r", "\n"], '', $reverse_dns);

  // Check if they are blocked
  $output = `iptables -n -L INPUT | grep $ip`;
  $blocked = empty($output) ? '' : '(BLOCKED) ';

  if (!$quiet) {
    echo "$blocked$ip - $count hits - {$info['org']} ({$info['country']}) {$info['timezone']} {$reverse_dns}\n";
  }

  if ($count > $limit) {
    // Block countries with high badbot-rates
    if (!$blocked && in_array($info['country'], ['BR', 'VN', 'UZ', 'IQ', 'CN', 'BH', 'MY'])) {
      // Check if it is an IPv4 address
      $parts = explode('.', $ip);
      if (count($parts) == 4) {
        if (!$quiet) {
          echo "Blocking: $ip/24 (because of country)\n";
        }
        `iptables -I INPUT -s $ip/24 -j DROP`;
      }
    }

    // Check if it's a bot on Google cloud, but not the Google Crawler
    if (!$blocked) {
      if (strpos($reverse_dns, 'googleusercontent.com') !== FALSE) {
        if (!$quiet) {
          echo "Blocking: $ip/24 (because of rDNS)\n";
        }
        `iptables -I INPUT -s $ip/24 -j DROP`;
      }
    }
  }

  $stop--;
  if (!$stop) {
    break;
  }
}
